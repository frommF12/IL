
# 객체지향

참고자료 자바의 정석 3rd  

* [클래스란](#클래스란)
* [변수](#클래스란)
* [메서드](#메서드)
* [멤버간의호출](#멤버간의호출)
* [오버로딩과가변인자](#오버로딩과가변인자)
* [생성자](생성자)

## 객체지향언어의 주요 특징

* 코드의 재사용성이 높다.
* 코드의 관리가 용이하다.
* 신뢰성이 높은 프로그래밍을 가능하게 한다.

창천향로님의 블랙잭 게임 구현 내용 중 다른 메서드가 어떤 구현을 하던 믿고 맡기라는 말씀이 기억난다.  

즉, 내가 호출한 메서드가 내부적으로 어떻게 돌아가는지는 몰라도 원하는 기능을 명확히 쓸 수 있으면 된다는 것 같다.  

아마 내가 자바의 API를 사용할 때도 이 말이 적용되는 것 같다.  

---

### 클래스란 


클래스는 ‘객체를 정의해놓은 것’ 또는 ‘객체의 설계도’라고 보면 된다.  

클래스는 객체를 설계하는 것 뿐이므로   

설계하는 과정에서 클래스에 집중하지말고 ‘객체’에 집중해야 한다.  



객체는 ‘실제로 존재하는 것’이다.   

책상,의자같은 유형적인 객체이나 수학공식, 게임규칙 같은 무형의 객체가 있다.  

프로그래밍에서 클래스를 구현하면 객체가 생성된다고 하는데 앞과는 다른 객체이다.  

여기서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.  



클래스를 구현해놓음으로써 객체를 중복된 코드없이 만들 수 있다.   

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며   

만들어진 객체를 인스턴스라고 한다  



객체는 다수의 속성과 기능으로 구성되어 있다.   

클래스에는 객체의 모든 속성과 기능이 정의되어 있다. 이를 토대로 객체가 만들어진다.  

속성(property)은 멤버변수, 필드라고 부르며  

기능(function)은 메서드, 함수라고 부른다.  

---
### 변수


변수의 선언된 위치에 따라서 변수의 종류가 달라진다.  

클래스 변수, 인스턴스 변수는 클래스 영역에서 선언된 변수이고 멤버변수라고 한다.  

지역변수는 클래스 이외의 영역(메서드, 생성자,for문 등)에서 선언된 변수이다.  

클래스 변수는 인스턴스 변수와는 달리 static 키워드가 붙었다   



- 인스턴스 변수  

        인스턴스 변수는 독립적인 공간을 가지므로 객체가 생성되었을 때  
        인스턴스마다 변수를 공유하지 않는다. 즉 다른 값을 가진다.  

- 클래스 변수 

        인스턴스 변수앞에 static 키워드를 붙이면 되는데  
        클래스 변수는 공통된 저장공간을 공유한다.  
        클래스 변수로 선언된 하나의 변수를 생성된 모든 인스턴스들이 공유한다.  
        객체를 생성하지 않고 “클래스이름.변수이름”으로 사용할 수 있다.  

- 지역 변수  

        지역변수로 선언된 변수는 그 지역을 벗어나면 소멸된다.  
        외부에서 지역변수를 참조를 할 수 없다.  
        A()의 test 변수와 B()의 test변수는 이름만 같아보일 뿐 서로 다른 변수이다.  
---
### 메서드


메서드 앞에 static이 붙어 있으면 클래스 메서드이고 없으면 인스턴스 메서드 이다. 

클래스 변수와 마찬가지로 “클래스이름.메서드이름”으로 객체를 생성하지 않고 사용할 수 있다.  

인스턴스는 변수든 메서드든 무조건 객체로 생성해야 사용할 수 있다.  

클래스 메서드는 인스턴스 변수, 메서드를 사용할 수 없다.  

    
> 인스턴스 변수나 메서드는 인스턴스가 생성되야 사용할 수 있는 반면 클래스 메서드는 그냥 사용할 수 있다.   
> 그래서 클래스 메서드가 생성되지 않은 인스턴스 변수나 메서드를 호출할 수 있으므로 사용을 금지한다.  

인스턴스 변수와 메서드는 언제나 static 변수와 메서드를 사용할 수있다.  

---

### 멤버간의호출


같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조나 호출이 가능하다.  

단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  

  → 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있음  
  
인스턴스 멤버간의 호출이나 수식은 상관이 없다.  

---

### 오버로딩과가변인자


메서드 오버로딩은 같은 메서드에서 매개변수의 개수 또는 타입을 다르게 해서 여러 개의 메서드를 정의할 수 있는 기능이다. 

오버로딩을 할려면 메서드 이름이 같아야 하고, 매개변수의 개수 또는 타입이 달라야 한다.  

오버로딩은 매개변수에 의해서만 구별되므로 반환타입은 아무런 영향을 주지 못한다.  

int add(int a, int b) 와 long add(int a, int b)는 리턴타입만 다른 경우이므로 에러가 난다.  

매개변수를 유동적으로 지정하고 싶다면 매개변수의 마지막에 “타입…변수명”으로 지정하면 된다. 

가변인자는 내부적으로 배열을 이용하므로 배열도 인자가 될 수 있다.  

가변인자를 사용한 메서드는 구별되지 못하는 경우가 있어 오버로딩은 하지 않는게 좋다.  

---

### 생성자


생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.  

따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서 사용된다.  


생성자의 조건은 다음과 같다.  

- 생성자의 이름은 클래스의 이름과 같아야 한다.   
- 생성자는 리턴 값이 없다. (void 키워드를 사용하지 않는다.)  


> 생성자도 메서드이기 때문에 리턴값이 없다는 void를 붙여야 하지만,  
> 모든 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다.  


생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.  


연산자는 인스턴스 변수들의 초기화에 사용되는 메서드이다.  

인스턴스를 생성하는 것이 아니다. 인스턴스 생성은 new 연산자가 한다.  


`Card c = new Card();`
Card 클래스의 인스턴스를 생성하는 코드가 수행되는 과정은 다음과 같다.  

1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.  
2. 생성자 Card()가 호출되어 수행된다.  
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.  


- **기본 생성자**


    모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.  
    
    클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는 것은 컴파일러가 제공하는   
    기본 생성자 덕분이다. (매개변수도 없고 아무런 내용이 없다.)  
    
    클래스내에 생성자가 하나도 없을 경우에만 자동적으로 추가하므로 다른 생성자를 만들었을 때   
    
    기본생성자가 추가되지 않는 것을 주의해야 한다.   

- **매개변수가 있는 생성자**


    매개변수로 값을 넘겨받아 생성자에서 인스턴스의 초기화를 할 수 있다.  
    
    상속을 하지 않고 기본 클래스로만 사용한다면 괜찮겠지만   
    
    상속을 염두에 둔다면 인스턴스 변수, 생성자를 고려해서 만들어야 될 것이다.   
    
    매개변수가 있는 생성자가 있으면 기본생성자가 자동으로 추가되지 않는다.   


- **생성자에서 다른 생성자 호출하기 - this(), this**


    같은 클래스의 멤버들간에 서로 호출할 수 있는 것처럼   
    
    다음 두가지의 조건을 만족시키면 생성자 간에도 서로 호출이 가능하다.  


    - 생성자의 이름으로 클래스이름 대신 this를 사용한다.  
    - 
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.  

```
Car (String color) {
door = 5;
Car(color, "auto", 4);
}
```
에러 1. 생성자의 두번째 줄에서 다른 생성자 호출  

에러 2. this로 다른 생성자를 호출하지 않음 this(color, "auto", 4);로 호출해야한다.  

생성자를 첫번째 줄에서만 호출이 가능한 것은  

기존의 생성자에서 초기화했던 작업이 호출된 생성자의 초기화 작업으로 인해  

무의미해질 수 있기 때문이다.  

```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}
```
인스턴스 변수와 매개변수의 이름이 같을 경우 인스턴스 변수에 this를 붙여줘서 구분한다.  

만약 color = color로 한다면 둘 다 지역변수로 간주된다.  




this는 참조변수로 인스턴스 자신을 가리킨다.  

참조변수를 통해 인스턴스의 멤버에 접근하는 것처럼 this도 인스턴스 멤버에 접근하는 것이다.  

this를 사용할 수 있는 것은 인스턴스 멤버뿐이다.  

static 멤버를 사용하는 시점에서 인스턴스가 존재하지 않을 수 있기 때문이다.  


요약 :  
this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.  
       모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
       
this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.  

this와 this()는 전혀 다른것이다.  


생성자를 이용해서 인스턴스를 복사할 수 있다.   
```
Car(Car c) {
color = c.color;
gearType = c.gearType;
door = c.door;
}
```
매개변수로 넘겨진 Car 참조변수로 인스턴스변수 값만 복사하는 것이다.  

이처럼 어떤 인스턴스의 상태를 전혀 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있다.  


```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}

Car(Car c) {
this(c.color, c.gearType, c.door);
}
```
생성자를 이용해 일일히 값을 변경하는 코드가 아닌 재사용이 가능한 코드로 짤 수 있다.  


인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.  

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?  
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?  
