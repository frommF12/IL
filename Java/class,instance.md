
# 객체지향

참고자료 자바의 정석 3rd  

* [클래스](#클래스)
* [변수](#변수)
* [메서드](#메서드)
* [멤버간의호출](#멤버간의호출)
* [오버로딩과가변인자](#오버로딩과가변인자)
* [생성자](#생성자)
* [상속](#상속)

## 객체지향언어의 주요 특징

* 코드의 재사용성이 높다.
* 코드의 관리가 용이하다.
* 신뢰성이 높은 프로그래밍을 가능하게 한다.

창천향로님의 블랙잭 게임 구현 내용 중 다른 메서드가 어떤 구현을 하던 믿고 맡기라는 말씀이 기억난다.  

즉, 내가 호출한 메서드가 내부적으로 어떻게 돌아가는지는 몰라도 원하는 기능을 명확히 쓸 수 있으면 된다는 것 같다.  

아마 내가 자바의 API를 사용할 때도 이 말이 적용되는 것 같다.  

---

### 클래스 


클래스는 ‘객체를 정의해놓은 것’ 또는 ‘객체의 설계도’라고 보면 된다.  

클래스는 객체를 설계하는 것 뿐이므로   

설계하는 과정에서 클래스에 집중하지말고 ‘객체’에 집중해야 한다.  



객체는 ‘실제로 존재하는 것’이다.   

책상,의자같은 유형적인 객체이나 수학공식, 게임규칙 같은 무형의 객체가 있다.  

프로그래밍에서 클래스를 구현하면 객체가 생성된다고 하는데 앞과는 다른 객체이다.  

여기서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.  



클래스를 구현해놓음으로써 객체를 중복된 코드없이 만들 수 있다.   

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며   

만들어진 객체를 인스턴스라고 한다  



객체는 다수의 속성과 기능으로 구성되어 있다.   

클래스에는 객체의 모든 속성과 기능이 정의되어 있다. 이를 토대로 객체가 만들어진다.  

속성(property)은 멤버변수, 필드라고 부르며  

기능(function)은 메서드, 함수라고 부른다.  

---
### 변수


변수의 선언된 위치에 따라서 변수의 종류가 달라진다.  

클래스 변수, 인스턴스 변수는 클래스 영역에서 선언된 변수이고 멤버변수라고 한다.  

지역변수는 클래스 이외의 영역(메서드, 생성자,for문 등)에서 선언된 변수이다.  

클래스 변수는 인스턴스 변수와는 달리 static 키워드가 붙었다   



- 인스턴스 변수  

        인스턴스 변수는 독립적인 공간을 가지므로 객체가 생성되었을 때  
        인스턴스마다 변수를 공유하지 않는다. 즉 다른 값을 가진다.  

- 클래스 변수 

        인스턴스 변수앞에 static 키워드를 붙이면 되는데  
        클래스 변수는 공통된 저장공간을 공유한다.  
        클래스 변수로 선언된 하나의 변수를 생성된 모든 인스턴스들이 공유한다.  
        객체를 생성하지 않고 “클래스이름.변수이름”으로 사용할 수 있다.  

- 지역 변수  

        지역변수로 선언된 변수는 그 지역을 벗어나면 소멸된다.  
        외부에서 지역변수를 참조를 할 수 없다.  
        A()의 test 변수와 B()의 test변수는 이름만 같아보일 뿐 서로 다른 변수이다.  
---
### 메서드


메서드 앞에 static이 붙어 있으면 클래스 메서드이고 없으면 인스턴스 메서드 이다. 

클래스 변수와 마찬가지로 “클래스이름.메서드이름”으로 객체를 생성하지 않고 사용할 수 있다.  

인스턴스는 변수든 메서드든 무조건 객체로 생성해야 사용할 수 있다.  

클래스 메서드는 인스턴스 변수, 메서드를 사용할 수 없다.  

    
> 인스턴스 변수나 메서드는 인스턴스가 생성되야 사용할 수 있는 반면 클래스 메서드는 그냥 사용할 수 있다.   
> 그래서 클래스 메서드가 생성되지 않은 인스턴스 변수나 메서드를 호출할 수 있으므로 사용을 금지한다.  

인스턴스 변수와 메서드는 언제나 static 변수와 메서드를 사용할 수있다.  

---

### 멤버간의호출


같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조나 호출이 가능하다.  

단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  

  → 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있음  
  
인스턴스 멤버간의 호출이나 수식은 상관이 없다.  

---

### 오버로딩과가변인자


메서드 오버로딩은 같은 메서드에서 매개변수의 개수 또는 타입을 다르게 해서 여러 개의 메서드를 정의할 수 있는 기능이다. 

오버로딩을 할려면 메서드 이름이 같아야 하고, 매개변수의 개수 또는 타입이 달라야 한다.  

오버로딩은 매개변수에 의해서만 구별되므로 반환타입은 아무런 영향을 주지 못한다.  

int add(int a, int b) 와 long add(int a, int b)는 리턴타입만 다른 경우이므로 에러가 난다.  

매개변수를 유동적으로 지정하고 싶다면 매개변수의 마지막에 “타입…변수명”으로 지정하면 된다. 

가변인자는 내부적으로 배열을 이용하므로 배열도 인자가 될 수 있다.  

가변인자를 사용한 메서드는 구별되지 못하는 경우가 있어 오버로딩은 하지 않는게 좋다.  

---

### 생성자


생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.  

따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서 사용된다.  


생성자의 조건은 다음과 같다.  

- 생성자의 이름은 클래스의 이름과 같아야 한다.   
- 생성자는 리턴 값이 없다. (void 키워드를 사용하지 않는다.)  


> 생성자도 메서드이기 때문에 리턴값이 없다는 void를 붙여야 하지만,  
> 모든 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다.  


생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.  


연산자는 인스턴스 변수들의 초기화에 사용되는 메서드이다.  

인스턴스를 생성하는 것이 아니다. 인스턴스 생성은 new 연산자가 한다.  


`Card c = new Card();`
Card 클래스의 인스턴스를 생성하는 코드가 수행되는 과정은 다음과 같다.  

1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.  
2. 생성자 Card()가 호출되어 수행된다.  
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.  


- **기본 생성자**


    모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.  
    
    클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는 것은 컴파일러가 제공하는   
    기본 생성자 덕분이다. (매개변수도 없고 아무런 내용이 없다.)  
    
    클래스내에 생성자가 하나도 없을 경우에만 자동적으로 추가하므로 다른 생성자를 만들었을 때   
    
    기본생성자가 추가되지 않는 것을 주의해야 한다.   

- **매개변수가 있는 생성자**


    매개변수로 값을 넘겨받아 생성자에서 인스턴스의 초기화를 할 수 있다.  
    
    상속을 하지 않고 기본 클래스로만 사용한다면 괜찮겠지만   
    
    상속을 염두에 둔다면 인스턴스 변수, 생성자를 고려해서 만들어야 될 것이다.   
    
    매개변수가 있는 생성자가 있으면 기본생성자가 자동으로 추가되지 않는다.   


- **생성자에서 다른 생성자 호출하기 - this(), this**


    같은 클래스의 멤버들간에 서로 호출할 수 있는 것처럼   
    
    다음 두가지의 조건을 만족시키면 생성자 간에도 서로 호출이 가능하다.  


    - 생성자의 이름으로 클래스이름 대신 this를 사용한다.  
    - 
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.  

```
Car (String color) {
door = 5;
Car(color, "auto", 4);
}
```
에러 1. 생성자의 두번째 줄에서 다른 생성자 호출  

에러 2. this로 다른 생성자를 호출하지 않음 this(color, "auto", 4);로 호출해야한다.  

생성자를 첫번째 줄에서만 호출이 가능한 것은  

기존의 생성자에서 초기화했던 작업이 호출된 생성자의 초기화 작업으로 인해  

무의미해질 수 있기 때문이다.  

```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}
```
인스턴스 변수와 매개변수의 이름이 같을 경우 인스턴스 변수에 this를 붙여줘서 구분한다.  

만약 color = color로 한다면 둘 다 지역변수로 간주된다.  




this는 참조변수로 인스턴스 자신을 가리킨다.  

참조변수를 통해 인스턴스의 멤버에 접근하는 것처럼 this도 인스턴스 멤버에 접근하는 것이다.  

this를 사용할 수 있는 것은 인스턴스 멤버뿐이다.  

static 멤버를 사용하는 시점에서 인스턴스가 존재하지 않을 수 있기 때문이다.  


요약 :  
this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.  
       모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
       
this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.  

this와 this()는 전혀 다른것이다.  


생성자를 이용해서 인스턴스를 복사할 수 있다.   
```
Car(Car c) {
color = c.color;
gearType = c.gearType;
door = c.door;
}
```
매개변수로 넘겨진 Car 참조변수로 인스턴스변수 값만 복사하는 것이다.  

이처럼 어떤 인스턴스의 상태를 전혀 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있다.  


```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}

Car(Car c) {
this(c.color, c.gearType, c.door);
}
```
생성자를 이용해 일일히 값을 변경하는 코드가 아닌 재사용이 가능한 코드로 짤 수 있다.  


인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.  

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?  
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가? 

---

### 상속


**상속이란**


기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

작성할 클래스 이름 뒤에 extends 키워드와 상속받을 클래스를 적어주면 된다. 

```class Child extends Parent ```

상속하는 클래스를 조상,부모(parent), 상위(super), 기반(base)클래스라고 하며  

상속받는 클래스는 자식(child), 하위(sub), 파생된(derived)클래스라고 한다.  



자손 클래스의 인스턴스를 생성하면   

조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다. 


- 상속받는 것들   
    조상 클래스의 모든 멤버를 상속받는다.  
    
    조상클래스의 멤버변수나 메서드가 자동으로 자손 클래스에 추가된다.  
    
    허나 자손 클래스에 멤버를 추가한다고 조상 클래스에도 추가되진 않는다.  
    
    생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.  
    


- 상속범위  
    자손 클래스가 부모 클래스의 모든 멤버를 상속받는다고 했으니까  
    
    자손 클래스(이 때는 부모클래스가 되는)를 상속하는 자손 클래스가 있다면  
    
    부모 클래스가 조상 클래스의 멤버를 상속받고 자손 클래스는 부모 클래스를 상속받기 때문에  
    
    자손 클래스는 조상 클래스와 간접 상속관계를 갖는다.  
    
    클래스간의 관계에서 형제관계같은 것은 없고 오로지 부모와 자식관계만 있다.  
    


- 중복 제거  
    상속을 하게 되면 조상 클래스에서 상속받는 클래스의 멤버를 추가, 제거함으로써  
    
    중복 코드를 줄일 수 있다.  
    
    그러면 각 코드가 적어져서 관리하기가 쉬워진다.  
    
    또는 코드가 엉켜서 문제를 일으킬 수 있기 때문에 전체 프로그램을 구성하는 클래스들을 면밀히 설계 분석하여, 클래스간의 상속관계를 적절히 맺어줘야 한다.  
    
**is a, has a**


클래스를 재사용하는 방법에는 상속이외에도 다른 방법도 있다.  

한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 건데  

예를  들면  

```
class Circle{
int x;
int y;
int r;
}

class Point{
int x;
int y;
}
```
Circle과 Point클래스가 있는데 Point클래스를 재사용해서 다음과 같이 작성할 수 있다.  

```
class Circle{
Point c = new Point();
int r;
}
```

이렇게 다른 클래스를 멤버변수로 선언하여 포함시키는 방법이 있다.  


그럼 클래스를 재사용할 때 상속관계와 포함관계 중에서 어떤 관계를 맺어줄건지 헷갈릴 때가 있다.  

그럴 땐 is a ( ~ 은 ~ 이다)와 has a ( ~  은 ~ 을 가지고 있다)를 이용하면 클래스 간의 관계를 명확히 설정할 수 있다.  


원(Circle)은 점(Point)이다 - Circle is a Point  

원(Circle)은 점(Point)을 가지고 있다 - Circle has a Point  

두번째 문장이 옳은 문장이므로 Circle과 Point클래스는 포함관계이다.  


SportsCar는 car이다 - is a  

Deck은 Card를 가지고 있다 - has a  
  

        상속관계는 is a  

        포함관계는 has a  

**단일상속**

자바는 다중상속을 제한하고 단일상속만 허용한다.  

다중상속을 할 경우 클래스간의 관계가 매우 복잡해지기 때문에 다중상속을 지원하지 않는다. 

만약 다중상속처럼 여러 클래스를 재사용하고 싶다면 하나의 클래스를 일단 상속을 받고  

다른 클래스는 포함해서 사용할 수 있다. 다음 예를 참고하자   

```
class TV{
boolean power; 
        void power() {}
}
class VCR {
        void play() {}
        void rew() {}
}

class TVCR extends TV{
VCR vcr = new VCR();
        void play() {
        vcr.paly();
}
void rew() {
        vcr.rew();
} 
}
```
VCR클래스를 TVCR클래스에 포함시켰다.  

VCR 클래스의 메서드 이름과 일치하는 메서드를 선언하고 내부적으로 VCR 클래스 메서드를 호출했다.  

외부적으로는 TVCR 클래스의 인스턴스를 사용하는 것 같지만 내부적으로는 VCR클래스의 인스턴스를 생성해서 사용하는 것이다.  

또한 VCR의 메서드 내용이 변경되더라도 TVCR 클래스의 메서드들도 변경된 내용이 적용된다.  

**Object 클래스**

자바의 클래스 상속 계층도에서 최상위에 있는 조상 클래스이다.  

따라서 모든 클래스는 Object 클래스를 상속받게 된다.  

Object에는 11가지의 메서드가 있다.  

