
# 객체지향

참고자료 자바의 정석 3rd  

* [클래스](#클래스)
* [변수](#변수)
* [메서드](#메서드)
* [멤버간의호출](#멤버간의호출)
* [오버로딩과가변인자](#오버로딩과가변인자)
* [생성자](#생성자)
* [상속](#상속)
* [오버라이딩](#오버라이딩)
* [패키지와임포트](#패키지와임포트)
* [제어자](#제어자)
* [다형성](#다형성)
* [추상클래스](#추상클래스)

## 객체지향언어의 주요 특징

* 코드의 재사용성이 높다.
* 코드의 관리가 용이하다.
* 신뢰성이 높은 프로그래밍을 가능하게 한다.

창천향로님의 블랙잭 게임 구현 내용 중 다른 메서드가 어떤 구현을 하던 믿고 맡기라는 말씀이 기억난다.  

즉, 내가 호출한 메서드가 내부적으로 어떻게 돌아가는지는 몰라도 원하는 기능을 명확히 쓸 수 있으면 된다는 것 같다.  

아마 내가 자바의 API를 사용할 때도 이 말이 적용되는 것 같다.  


## 클래스 

클래스는 ‘객체를 정의해놓은 것’ 또는 ‘객체의 설계도’라고 보면 된다.  

클래스는 객체를 설계하는 것 뿐이므로   

설계하는 과정에서 클래스에 집중하지말고 ‘객체’에 집중해야 한다.  



객체는 ‘실제로 존재하는 것’이다.   

책상,의자같은 유형적인 객체이나 수학공식, 게임규칙 같은 무형의 객체가 있다.  

프로그래밍에서 클래스를 구현하면 객체가 생성된다고 하는데 앞과는 다른 객체이다.  

여기서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.  



클래스를 구현해놓음으로써 객체를 중복된 코드없이 만들 수 있다.   

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며   

만들어진 객체를 인스턴스라고 한다  



객체는 다수의 속성과 기능으로 구성되어 있다.   

클래스에는 객체의 모든 속성과 기능이 정의되어 있다. 이를 토대로 객체가 만들어진다.  

속성(property)은 멤버변수, 필드라고 부르며  

기능(function)은 메서드, 함수라고 부른다.  


## 변수

변수의 선언된 위치에 따라서 변수의 종류가 달라진다.  

클래스 변수, 인스턴스 변수는 클래스 영역에서 선언된 변수이고 멤버변수라고 한다.  

지역변수는 클래스 이외의 영역(메서드, 생성자,for문 등)에서 선언된 변수이다.  

클래스 변수는 인스턴스 변수와는 달리 static 키워드가 붙었다   



- 인스턴스 변수  

        인스턴스 변수는 독립적인 공간을 가지므로 객체가 생성되었을 때  
        인스턴스마다 변수를 공유하지 않는다. 즉 다른 값을 가진다.  

- 클래스 변수 

        인스턴스 변수앞에 static 키워드를 붙이면 되는데  
        클래스 변수는 공통된 저장공간을 공유한다.  
        클래스 변수로 선언된 하나의 변수를 생성된 모든 인스턴스들이 공유한다.  
        객체를 생성하지 않고 “클래스이름.변수이름”으로 사용할 수 있다.  

- 지역 변수  

        지역변수로 선언된 변수는 그 지역을 벗어나면 소멸된다.  
        외부에서 지역변수를 참조를 할 수 없다.  
        A()의 test 변수와 B()의 test변수는 이름만 같아보일 뿐 서로 다른 변수이다.  
        
## 메서드

메서드 앞에 static이 붙어 있으면 클래스 메서드이고 없으면 인스턴스 메서드 이다. 

클래스 변수와 마찬가지로 “클래스이름.메서드이름”으로 객체를 생성하지 않고 사용할 수 있다.  

인스턴스는 변수든 메서드든 무조건 객체로 생성해야 사용할 수 있다.  

클래스 메서드는 인스턴스 변수, 메서드를 사용할 수 없다.  

    
> 인스턴스 변수나 메서드는 인스턴스가 생성되야 사용할 수 있는 반면 클래스 메서드는 그냥 사용할 수 있다.   
> 그래서 클래스 메서드가 생성되지 않은 인스턴스 변수나 메서드를 호출할 수 있으므로 사용을 금지한다.  

인스턴스 변수와 메서드는 언제나 static 변수와 메서드를 사용할 수있다.  



## 멤버간의호출

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조나 호출이 가능하다.  

단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.  

  → 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있음  
  
인스턴스 멤버간의 호출이나 수식은 상관이 없다.  



## 오버로딩과가변인자

메서드 오버로딩은 같은 메서드에서 매개변수의 개수 또는 타입을 다르게 해서 여러 개의 메서드를 정의할 수 있는 기능이다. 

오버로딩을 할려면 메서드 이름이 같아야 하고, 매개변수의 개수 또는 타입이 달라야 한다.  

오버로딩은 매개변수에 의해서만 구별되므로 반환타입은 아무런 영향을 주지 못한다.  

int add(int a, int b) 와 long add(int a, int b)는 리턴타입만 다른 경우이므로 에러가 난다.  

매개변수를 유동적으로 지정하고 싶다면 매개변수의 마지막에 “타입…변수명”으로 지정하면 된다. 

가변인자는 내부적으로 배열을 이용하므로 배열도 인자가 될 수 있다.  

가변인자를 사용한 메서드는 구별되지 못하는 경우가 있어 오버로딩은 하지 않는게 좋다.  



## 생성자

생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.  

따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서 사용된다.  


생성자의 조건은 다음과 같다.  

- 생성자의 이름은 클래스의 이름과 같아야 한다.   
- 생성자는 리턴 값이 없다. (void 키워드를 사용하지 않는다.)  


> 생성자도 메서드이기 때문에 리턴값이 없다는 void를 붙여야 하지만,  
> 모든 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다.  


생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.  


연산자는 인스턴스 변수들의 초기화에 사용되는 메서드이다.  

인스턴스를 생성하는 것이 아니다. 인스턴스 생성은 new 연산자가 한다.  


`Card c = new Card();`
Card 클래스의 인스턴스를 생성하는 코드가 수행되는 과정은 다음과 같다.  

1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.  
2. 생성자 Card()가 호출되어 수행된다.  
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.  


- **기본 생성자**


    모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.  
    
    클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는 것은 컴파일러가 제공하는   
    기본 생성자 덕분이다. (매개변수도 없고 아무런 내용이 없다.)  
    
    클래스내에 생성자가 하나도 없을 경우에만 자동적으로 추가하므로 다른 생성자를 만들었을 때   
    
    기본생성자가 추가되지 않는 것을 주의해야 한다.   

- **매개변수가 있는 생성자**


    매개변수로 값을 넘겨받아 생성자에서 인스턴스의 초기화를 할 수 있다.  
    
    상속을 하지 않고 기본 클래스로만 사용한다면 괜찮겠지만   
    
    상속을 염두에 둔다면 인스턴스 변수, 생성자를 고려해서 만들어야 될 것이다.   
    
    매개변수가 있는 생성자가 있으면 기본생성자가 자동으로 추가되지 않는다.   


- **생성자에서 다른 생성자 호출하기 - this(), this**


    같은 클래스의 멤버들간에 서로 호출할 수 있는 것처럼   
    
    다음 두가지의 조건을 만족시키면 생성자 간에도 서로 호출이 가능하다.  


    - 생성자의 이름으로 클래스이름 대신 this를 사용한다.  
    - 
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.  

```
Car (String color) {
door = 5;
Car(color, "auto", 4);
}
```
에러 1. 생성자의 두번째 줄에서 다른 생성자 호출  

에러 2. this로 다른 생성자를 호출하지 않음 this(color, "auto", 4);로 호출해야한다.  

생성자를 첫번째 줄에서만 호출이 가능한 것은  

기존의 생성자에서 초기화했던 작업이 호출된 생성자의 초기화 작업으로 인해  

무의미해질 수 있기 때문이다.  

```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}
```
인스턴스 변수와 매개변수의 이름이 같을 경우 인스턴스 변수에 this를 붙여줘서 구분한다.  

만약 color = color로 한다면 둘 다 지역변수로 간주된다.  




this는 참조변수로 인스턴스 자신을 가리킨다.  

참조변수를 통해 인스턴스의 멤버에 접근하는 것처럼 this도 인스턴스 멤버에 접근하는 것이다.  

this를 사용할 수 있는 것은 인스턴스 멤버뿐이다.  

static 멤버를 사용하는 시점에서 인스턴스가 존재하지 않을 수 있기 때문이다.  


요약 :  
this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.  
       모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
       
this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.  

this와 this()는 전혀 다른것이다.  


생성자를 이용해서 인스턴스를 복사할 수 있다.   
```
Car(Car c) {
color = c.color;
gearType = c.gearType;
door = c.door;
}
```
매개변수로 넘겨진 Car 참조변수로 인스턴스변수 값만 복사하는 것이다.  

이처럼 어떤 인스턴스의 상태를 전혀 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있다.  


```
Car(String color, String gearType, int door) {
this.color = color;
this.gearType = gearType;
this.door = door;
}

Car(Car c) {
this(c.color, c.gearType, c.door);
}
```
생성자를 이용해 일일히 값을 변경하는 코드가 아닌 재사용이 가능한 코드로 짤 수 있다.  


인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.  

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?  
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가? 



## 상속

**상속이란**


기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

작성할 클래스 이름 뒤에 extends 키워드와 상속받을 클래스를 적어주면 된다. 

```class Child extends Parent ```

상속하는 클래스를 조상,부모(parent), 상위(super), 기반(base)클래스라고 하며  

상속받는 클래스는 자식(child), 하위(sub), 파생된(derived)클래스라고 한다.  



자손 클래스의 인스턴스를 생성하면   

조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다. 


- 상속받는 것들   
    조상 클래스의 모든 멤버를 상속받는다.  
    
    조상클래스의 멤버변수나 메서드가 자동으로 자손 클래스에 추가된다.  
    
    허나 자손 클래스에 멤버를 추가한다고 조상 클래스에도 추가되진 않는다.  
    
    생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.  
    


- 상속범위  
    자손 클래스가 부모 클래스의 모든 멤버를 상속받는다고 했으니까  
    
    자손 클래스(이 때는 부모클래스가 되는)를 상속하는 자손 클래스가 있다면  
    
    부모 클래스가 조상 클래스의 멤버를 상속받고 자손 클래스는 부모 클래스를 상속받기 때문에  
    
    자손 클래스는 조상 클래스와 간접 상속관계를 갖는다.  
    
    클래스간의 관계에서 형제관계같은 것은 없고 오로지 부모와 자식관계만 있다.  
    


- 중복 제거  
    상속을 하게 되면 조상 클래스에서 상속받는 클래스의 멤버를 추가, 제거함으로써  
    
    중복 코드를 줄일 수 있다.  
    
    그러면 각 코드가 적어져서 관리하기가 쉬워진다.  
    
    또는 코드가 엉켜서 문제를 일으킬 수 있기 때문에 전체 프로그램을 구성하는 클래스들을 면밀히 설계 분석하여, 클래스간의 상속관계를 적절히 맺어줘야 한다.  
    
**is a, has a**


클래스를 재사용하는 방법에는 상속이외에도 다른 방법도 있다.  

한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 건데  

예를  들면  

```
class Circle{
int x;
int y;
int r;
}

class Point{
int x;
int y;
}
```
Circle과 Point클래스가 있는데 Point클래스를 재사용해서 다음과 같이 작성할 수 있다.  

```
class Circle{
Point c = new Point();
int r;
}
```

이렇게 다른 클래스를 멤버변수로 선언하여 포함시키는 방법이 있다.  


그럼 클래스를 재사용할 때 상속관계와 포함관계 중에서 어떤 관계를 맺어줄건지 헷갈릴 때가 있다.  

그럴 땐 is a ( ~ 은 ~ 이다)와 has a ( ~  은 ~ 을 가지고 있다)를 이용하면 클래스 간의 관계를 명확히 설정할 수 있다.  


원(Circle)은 점(Point)이다 - Circle is a Point  

원(Circle)은 점(Point)을 가지고 있다 - Circle has a Point  

두번째 문장이 옳은 문장이므로 Circle과 Point클래스는 포함관계이다.  


SportsCar는 car이다 - is a  

Deck은 Card를 가지고 있다 - has a  
  

        상속관계는 is a  

        포함관계는 has a  

**단일상속**

자바는 다중상속을 제한하고 단일상속만 허용한다.  

다중상속을 할 경우 클래스간의 관계가 매우 복잡해지기 때문에 다중상속을 지원하지 않는다. 

만약 다중상속처럼 여러 클래스를 재사용하고 싶다면 하나의 클래스를 일단 상속을 받고  

다른 클래스는 포함해서 사용할 수 있다. 다음 예를 참고하자   

```
class TV{
boolean power; 
        void power() {}
}
class VCR {
        void play() {}
        void rew() {}
}

class TVCR extends TV{
VCR vcr = new VCR();
        void play() {
        vcr.paly();
}
void rew() {
        vcr.rew();
} 
}
```
VCR클래스를 TVCR클래스에 포함시켰다.  

VCR 클래스의 메서드 이름과 일치하는 메서드를 선언하고 내부적으로 VCR 클래스 메서드를 호출했다.  

외부적으로는 TVCR 클래스의 인스턴스를 사용하는 것 같지만 내부적으로는 VCR클래스의 인스턴스를 생성해서 사용하는 것이다.  

또한 VCR의 메서드 내용이 변경되더라도 TVCR 클래스의 메서드들도 변경된 내용이 적용된다.  

**Object 클래스**

자바의 클래스 상속 계층도에서 최상위에 있는 조상 클래스이다.  

따라서 모든 클래스는 Object 클래스를 상속받게 된다.  

Object에는 11가지의 메서드가 있다.  


## 오버라이딩
        override : ~위에 덮어쓰다

오버라이딩 VS 오버로딩  

오버라이딩 : 부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것  


오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것 (매개변수의 개수, 순서 등을 바꿔서)  

오버라이딩 조건  

- 이름이 같아야 한다.    

- 매개변수가 같아야 한다.    

- 반환타입이 같아야 한다.    

- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.  

접근 제어자 범위 내림차순(public, protected, default, private)  

- 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.  

예외의 상속관계도 높으면 안된다.  

- 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.  

부모 클래스에 정의된 static 메서드를 자식 클래스에서도 똑같은 이름의 static 메서드로 정의할 수 있다.  

호출할 때는 “참조변수.메서드이름()” 보다는 “클래스이름.메서드이름()”으로 하는 게 좋다.  

**super**  

클래스의 멤버변수와 지역변수의 이름이 같을 때 this를 사용했듯이,  

부모 클래스의 멤버와 자식의 멤버가 같을 때는 super를 붙여서 구별한다.  

(부모와 자식의 멤버는 중복될 수 있다.)  
```
  class Parent {
    int x = 10;
  }
  class Child extends Parent {
    int x = 20;
  }
  // super.x = 10 / this.x = 20
  다음과 같이
  오버라이딩한 메서드도 super 키워드를 써서 부모 클래스의 메서드를 호출 할 수 있다.
  class Point {
    String getLocation() {
        return "x : "+ x;
    }
  }
  class point3D {
    String getLocation() {
        //return "x : " + x + ", y : " + y;
        super.getLocation() + ", y : " + y;
    }
  }
```
이렇게 super를 이용해서 부모클래스의 메서드를 포함시킨다면 부모 클래스의 메서드가 변경되었을 때  

변경된 내용이 자손 클래스의 메서드에 자동적으로 반영될 수 있으므로 관리가 편하다.  

super()  

super() 는 부모클래스의 생성자이다  
  
클래스를 상속받으면 자식클래스의 생성자 첫 줄에서 부모 클래스의 생성자를 호출한다.  

(Object() 생성자까지 계속 호출한다.)  

그래서 생성자 첫 줄에 super(매개변수)나 this()를 호출해줘야한다.  

호출하지 않으면 컴파일러가 자동으로 super()를 호출한다.  

자식에서 super()를 호출하지 않고 부모 클래스에서 빈 생성자가 없다면 컴파일에러가 발생한다.  

컴파일러는 생성자가 정의되어 있는 클래스에는 기본 생성자를 자동으로 추가하지 않기 때문에 발생하는 오류이다.  

오류를 해결하려면 부모의 생성자에 맞게 super(매개변수)를 호출하면 된다.  

  
## 패키지와임포트

**package**

패키지란, 클래스의 묶음이다.

패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 크래스를 효율적으로 관리할 수 있다.

같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능하므로, 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와의 이름이 충돌됨을 피할 수 있다.

클래스의 실제 이름은(full name) 패키지명을 포함한 것이다.

예를 들어 String 클래스의 패키지명을 포함한 이름은 java.lang.String이다.

java.lang 패키지에 속한 String클래스라는 의미이다.

그래서 같은 이름의 클래스일지라도 서로 다른 패키지에 속하면 패키지명으로 구별이 가능하다.

클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적을 하나의 디렉토리다.

java.lang.String는 물리적으로 디렉토리 java의 서브디렉토리인 lang에 속한 String.class파일이다.

패캐지도 다른 패키지를 포함할 수 있으며 ‘ . ‘ 점으로 구분한다.

java.lang 패키지에서 lang패키지는 java 패키지의 하위 패키지이다.

하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.

모든 클래스는 반드시 하나의 패키지에 속해야 한다.

패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.

패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

**package declaration**

package 패키지명; 을 소스파일에서 주석과 공백을 제외한 첫 번째 문자이어야 하며 단 한번만 선언한다. 해당 소스파일에 포함된 모든 클래스나 인터페이스는 선언된 패키지에 속하게 된다.

**패키지명은 대소문자를 모두 허용하지만, 클래스명과 쉽게 구분하기 위해서 소문자로 하는게 원칙이다**

이후의 패키지에 대한 내용은 책 참고

**import**

소스코드를 작성할 때는 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. (매번 패키지명을 붙여서 사용하기 불편하다)

클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면

사용할 클래스의 이름에서 패키지명을 생략할 수 있다.

import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다

컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여준다.

*import문은  프로그램의 성능에 전혀 영향을 미치지 않는다.*

*import문을 많이 사용하면 컴파일 시간이 아주 조금 더 걸릴 뿐이다.*

**import declaration**

소스파일의 구성은 다음 순서로 되어있다.

1. package문
2. import문
3. 클래스 선언

import문을 선언하는 방법은 다음과 같다.

- import 패키지명.클래스명;
- import 패키지명. *;

패키지명.*을 사용하는 것이 하위 패키지의 클래스까지 포함하는 것이 아니다.

- import java.util.*;
- import java.text.*;

- import java.*;  - 이 문장은 위의 문장 대신 사용할 수 없다.

import문을 사용하지 않으면 일일히 클래스이름 앞에 패키지명을 적어야된다.

**static import statement**

import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이

static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

`import static java.lang.System.out;  // System.out을 out으로만 참조가능`

`import static java.lang.Math.random  // Math.random 메서드만 선언`

`System.out.println(Math.random()); -> out.println(random());`

## 제어자

### **What is Modifier?**

제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

**접근 제어자 -** public, protected, default, private

**그 외 -**  static, final, abstract, native, transient, syschronized, volatile, strictfp

제어자는 클래스나 멤버변수와 메서드에 주로 사용되며,

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

**단, 접근 제어자는 네 가지중 하나만 선택해서 사용할 수 있다.**

### **static**

static은 ‘클래스의’ , ‘공통적인’, ‘정적인’의 의미를 가지고 있다.

클래스 변수는 모든 인스턴스가 공유하는 변수다.

static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스를 생성하지 않고 사용한다.

static과 인스턴스의 차이는 인스턴스 멤버를 사용하는 여부이다.

```
static이 사용될 수 있는 곳 - **멤버변수, 메서드, 초기화 블럭**
```

static 멤버변수

- 모든 인스턴스에 공통적으로 사용된다.
- 인스턴스를 생성하지 않고 사용된다.
- 클래스가 메모리에 로드될 때 생성된다.

static 메서드

- 인스턴스를 생성하지 않고 호출된다.
- 메서드내에서 인스턴스 멤버들을 직접 사용할 수 없다.

인스턴스 멤버를 사용하지 않는 메서드는 static을 붙이는 것을 고려하자

static메서드로 하는 것이 더 편리하고 속도도 더 빠르다.

### final

final은 '마지막의', '변경될 수 없는' 의 의미를 가지고 있으며 

클래스,  메서드,  멤버변수,  지역변수에 사용가능하다.

- 클래스

    변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.

    final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.

- 메서드

    변경될 수 없는 메서드, 

    final로 지정된 메서드는 오버라이딩을 할 수 없다.

- 멤버변수, 지역변수

    final로 지정된 멤버,지역변수는 값을 변경할 수 없는 상수가 된다.

**생성자를 이용한 final 멤버 변수의 초기화**

final 변수는 일반적으로 선언과 초기화를 동시에 하지만, 

인스턴스 변수의 경우 생성자에서 초기화할 수 있다.

각 인스턴스는 final 변수의 값을 다르게 가질 수 있다.

### abstract

abstract는 '미완성의'의미를 가진다.

메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용된다.

추상클래스는 완성되지 않은 메서드가 존재하므로 인스턴스를 생성할 수 없다.

abstract가 사용되는 곳 - 클래스, 메서드

**abstract classs**
메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용된다

**abstract 메서드**
선언부만 작성하고 구현부는 작성하지 않은 추상메서드를 알림

추상클래스를 활용할 수 있는 방법 중 하나는WindowAdapter 추상클래스같이 

내용이 없는 메서드들만 정의를 한 후 

상속받은 자손클래스가 일부의 원하는 메서즈만 오버라이딩 할 수 있게 만들 수 있다.

WindowAdapter클래스는 다음과 같다.

```java
public abstract class WindowAdapter
	implements WindowListener, WindowStateListener, WindowFocusListener{
		public void windowOpened(WindowEvent e) {}
		public void windowClosing(WindowEvent e) {}
		...
}
```

이렇게 아무런 내용이 없는 메서드들만 정의되어있기에 인스턴스를 생성하지 못하도록 abstract 제어자를 붙였다.

### accees modifier

멤버 또는 클래스에 사용되며 

해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한할 수 있다.

접근제어자를 지정하지 않으면 default로 지정된다.

접근 제어자의 종류는 다음과 같다.

- **private**

    같은 클래스 내에서만 접근이 가능하다.
    클래스 내부에서만 사용가능하다. 

    외부에서는 접근이 불가능하다. 

    상속을 할 때 private 멤버는 자손 클래스에서도 접근불가이다.

- **default**

    같은 패키지 내에서만 접근이 가능하다.

- **protected**

    같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다. 

    default에서 상속받은 클래스까지 접근가능하다.(다른 패키지더라도 상속받으면 된다.)

- public

    접근 제한이 전혀 없다.

접근 범위가 넓은 쪽에서 내림차순
public > protected > default > private

각 대상 별 사용가능한 접근 제어자들

- **클래스 - public, default**
하나의 소스파일(.java)에는 public클레스가 단 하나만 존재할 수 있고, 소스파일의 이름은 반드시 public클래스 이름과 같아야한다.
default 클래스는 동일 패키지 내에서만 인스턴스 생성이 가능하다.
public은 어디에서나 인스턴스를 생성할 수 있다.
- **메서드, 멤버변수 - public, protected, default, private**
- **지역변수 - 없음**

접근 제어자를 사용하는 이유(접근제어자를 이용한 캡슐화)

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

접근범위가 넓을 때는 멤버를 변경시켰을 때 오류가 없는지 테스트 해야되는 범위도 넓다.
좁을 때는 접근 가능한 범위내에서만 테스트 하면 되기에 접근범위를 최소한으로 하는게 좋다.

접근제어자를 사용하여 외부로부터 보호하는 방법은

private나 protectes로 지정하여 노출을 시키지 않고 

멤버변수의 값을 읽고 변경할 수 있는 public메서드를 제공한다. 

메서드를 통해 간접적으로 값을 다룰 수 있게 한다.

직접적으로 접근하게 하면 데이터를 보호할 수 없지만 

메서드를 통해 간접적으로 제한하면 제약을 걸 수 있어서 보호가 가능하다.

아래와 같이 캡슐화를 할 수 있다.

```java
private int hour;

public int getHour() { return hour; } //게터

public void setHour(int hour) { //세터
	if (hour <  0 || hour > 23) return;
	this.hour = hour;
}
```

### access modifier of constructor

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
보통은 생성자와 클래스의 접근 제어자는 같지만 다르게 지정할 수 있다.

**private 생성자**
내부적으로만 이 생성자를 호출할 수 있다
외부에서는 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다.

대신 인스턴스를 생성해서 반환해주는 public메서드를 제공해서 외부에서 인스턴스를 사용하도록 할 수 있다.
이 메서드는 public동시에 static이어야한다.

```java
class Singleton{
	private static Singleton s = new Singleton();
		//getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야한다.
	
	private Singleton() {}

	public static Singleton getInstance() {
		return s;
	}
}
```

이처럼 생성자를 통해 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.

또한 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
자손클래스가 부모의 생성자를 호출할 수 없기 때문이다.
그래서 final 제어자를 추가하여 상속할 수 없은 클래스라고 알리는 것이 좋다.

생성자가 여러 개여서 다른 생성자를 호출할 수 있다면 다른 상황이 될 거 같다.

클래스와 생성자의 관계

- 클래스는 public인데 생성자가 default인 경우
패키지내에서만 인스턴스 생성가능
- 클래스는 default인데 생성자가 public인 경우
동일 패키지내에서만 인스턴스 생성가능

제어자의 조합(사용가능한)

**클래스 - public , default, final, abstract
메서드 - 모든 접근 제어자, final, abstract, static
멤버변수 - 모든 접근 제어자, final, static
지역변수 - static**

주의사항

- **메서드에 static과 abstract를 함께 사용할 수 없다.**
*static메서드는 구현되어있는 메서드에만 사용할 수 있다.*
- **클래스에 abstract와 final을 동시에 사용할 수 없다.**
*상속할 수 없는 final과 상속을 통해서 완성되어야하는 abstract는 서로 모순된다*
- **abstract 메서드의 접근 제어자가 private일 수 없다.**
*abstract 메서드는 자손 클래스에서 구현해야하는데 
private면 자손 클래스에서 접근할 수 없기 때문이다.*
- **메서드에 private와 final을 같이 사용할 필요는 없다.**
*접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 
둘 중 하나만 사용해도 의미가 충분하다.*

## 다형성

### what is polymorphism?

다형성은 상속과 깊은 관계가 있다.
객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며,

자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현했다.

즉, 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하는 것이다

```java
class Tv {
	boolean power;
	int channel;

	void power();
	void channelUP();
	void channelDown();
}

class CaptionTv extends Tv{
	String text;
	void caption() {}
}
```

Tv클래스와 CaptionTv클래스가 정의되어 있을 때, 두 클래스간의 관계는 상속관계이다.

상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것이 가능하다.

```java
CaptionTv c = new CaptionTv();
Tv t = new CatptionTv(); // 부모 타입의 참조변수로도 가능하다.
```

이 둘의 차이점은 참조변수의 타입에 따라 사용할 수 이는 멤버의 개수가 달라진다.

Tv타입의 참조변수로는 CaptionTv 인스턴스 중에서 상속받은 Tv클래스의 멤버들만 사용할 수 있다.

따라서 생성된 CaptionTv 인스턴스 멤버 중 TV클래스에 정의되지 않은 멤버, text와 caption()은 참조변수 t로 사용이 불가능하다.

반대로 **자손타입의 참조변수**로 **조상타입의 인스턴스**를 참조하는 것은 "불가능"하다.

실제 인스턴스인 Tv의 멤버 개수보다 자손타입의 참조변수가 사용할 수 있는 멤버개수가 더 많기 때문이다.

참조변수가 사용할 수 있는 멤버개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

- 클래스는 상속을 통해서 확장될 수 있는 있어도 축소될 수는 없기에 조상 인스턴스는 멤버 개수는 자손 인스턴스의 멤버 개수보다 항상 같거나 같다.

*모든 참조변수는 null 또는 4 byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.*

그런데 왜 조상타입의 참조변수를 사용할까?

### Casting reference variable

기본형 변수와 같이 참조변수도 형변환이 가능하다.

단, 서로 상속관계에 있는 클래스사이에서만 가능하므로 

자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로 형변환이 가능하다.

- 바로 윗 조상이나 자손이 아닌, 조상의 조상으로도 형변환이 가능하다. 
따라서 모든 참조변수는 Object클래스 타입으로 형변환이 가능하다.

자손타입에서 조상타입으로의 형변환은 생략이 가능하나 그 반대는 불가하다.

- 조상에서 자손타입으로 형변환을 햇을 때는 다룰 수 있는 멤버의 개수가 같거나 많기 때문에 형변환을 무조건 해야한다.

형변환은 자유롭지만 안되는 경우가 있다.

- 부모타입 참조변수가 부모타입의 인스턴스를 가리키고 있을 때 자식타입 참조변수가 부모타입의 참조변수값을 참조하려 할 때
    - 자손 클래스는 조상 클래스보다 멤버가 같거나 많기 때문에 
    조상타입의 인스턴스를 자손타입의 참조변수가 참조하는 것은 불가능하다

형변환이 양방향으로 자유롭게 수행될 수 있으나(컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행시 생성될 인스턴스의 타입에 대해서 전혀 알지못한다)
참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.

참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.

```java
FireEngine fe = new FireEngine();
Car c = fe;
FireEngine fe2 = (FireEngine) c;
```

이런 경우엔 가능하다. fe를 가리키고 있는 참조변수 c를  fe2가 다운캐스팅으로 형변환을 했다.

```java
Car c = new Car();
FireEngine fe = (FireEngine) c;
```

이런 경우엔 불가능하다. 참조변수 c는 Car타입의 인스턴스를 참조하고 있으므로
조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.

조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것을 down-casting이라고 하며,

그 반대는 up-casting이라고 한다.

형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것이 아니기 때문에
참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.

단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의
개수(범위)를 조절하는 것 뿐이다.

**요약**

부모타입의 참조변수가 자식타입의 인스턴스를 참조할 수 있다. (형변환 생략)

양방향 형변환을 할 수 있는데 

부모타입의 참조변수는 언제나 자식타입의 인스턴스를 참조할 수 있지만

자식타입의 참조변수는 부모타입의 인스턴스를 참조할 때 제약이 있다.

- 가능

    부모타입의 참조변수가 자식타입의 인스턴스를 참조했을 때 down casting 가능

- 불가능

    부모타입의 참조변수가 부모타입의 인스턴스를 참조했을 때 down casting 불가능

조상타입의 참조변수와 자식타입의 참조변수는 사용할 수 있는 멤버의 개수가 다르다.

### instanceof

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다.

instanceof의 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 위치한다.

연산의 결과값으로 boolean(true/ flase)을 반환한다.

- 값이 null인 참조변수에 대해 수행하면 false를 얻는다.

```java
void doWork(Car c) {
	if (c instanceof FireEngine) {
			FireEngine fe = (FireEngine) c;
			fe.water();
	} else if (c instanceof Ambulance) {
				Ambulance a = (Ambulance) c;
				a.siren();
	}
```

Car 타입으로 매개변수를 받고 instanceof 메서드를 활용해서 정확히 어떤 인스턴스인지  구분한다.

조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있기 때문에 참조변수의 타입와 인스턴스의 타입이 일치하지 않는다. 형변환을 통해 인스턴스의 멤버들을 모두 사용한다. (down-casting)

**여기서 알 수 있는 것은** 

**어떤 타입에 대한 instanceof연산의 결과가**

**true라는 것은 참조변수가 검사한 타입으로 형 변환이 가능하다는 것이다.**

instanceof연산자는 실제 인스턴스와 같은 타입의 instanceof 연산 이외에 조상타입의 instanceof연산에도 true를 결과로 얻는다.

```java
FireEngine instanceof Car//true
FireEngine instanceof Object // true
```

자손 클래스인 FireEngine은 부모 클래스로부터 상속을 받았기에 Object 인스턴스와 Car인스턴스를 포함하고 있는 셈이기 때문이다.

### Connection of reference variable and Instance

조상클래스의 멤버의 이름을 자손 클래스에서 중복해서 사용할 경우 참조변수의 타입에 따라

결과가 달라지게 된다.

- 조상클래스의 메서드를 오버라이딩 한 경우

    어떤 타입의 참조변수이든 간에 오버라이딩된 메서드(실제 인스턴스 메서드)가 호출된다.
    메서드는 참조변수의 타입에 관계없이 실제 인스턴스에 구현된 것이 호출된다.

- 조상클래스와 같은 이름의 인스턴스 변수를 자손 클래스에서 정의한 경우

    참조변수의 타입에 따라 달라진다. (조상이면 조상변수, 자손이면 자손 변수)

- *참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
static 메서드, static 변수도 참조변수의 타입에 영향을 받는다.
static 멤버들은 반드시 참조변수가 아닌 "클래스이름.메서드()"로 호출해야한다.*

### Polymorphism of parameter

argument : 인수

parameter : 매개변수

**자식 클래스가 여러 개 있을 때 parameter값으로 일일히 자식클래스마다 오버로딩하는 것보다

부모클래스의 참조변수를 parameter값으로 선언하여 다형성을 적용하면 간단히 처리할 수 있다.**

예를 들어 PrintStream 클래스에 정의되어있는 print(Object obj)는 Object타입 변수가 선언되어 있다

Object 클래스는 모든 클래스의 조상이므로 어떤 타입의 인스턴스이던 매개변수로 받을 수 있다.

이 하나의 메서드로 모든 타입의 인스턴스를 처리할 수 있는 것이다.

```java
public void print(Object obj) {
        write(String.valueOf(obj));
}

public static String valueOf(Object obj) {
        return (obj == null) ? "null" : obj.toString();
}
```

### polymorphism array

자손타입의  인스턴스를 여러개 생성했을 때 효율적으로 관리하는 방법으로

부모타입의 객체배열로 인스턴스들을 관리하는 것이다.

```java
Parent parent = new Parent[3];
parent[0] = new Harry();
parent[1] = new Reul();
parent[2] = new Lauv();
```

동적으로 크기가 관리되는 배열을 만들고 싶다면 Vector클래스를 사용하면 된다.

## 추상클래스

### what is abstract class?

클래스를 설계도라 하면 추상클래스는 미완성 설계도이다. 

미완성 설계도란 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.(포함하고 있지않아도 추상클래스로 만들어도 된다)

클래스 이름 앞에 키워드 'abstract'를 붙이면 추상클래스가 된다.

abstract 클래스이름{}

- 추상클래스는 인스턴스를 생성할 수 없고 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
- 추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 전혀 다르지 않다.
    - 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.

### abstract method

메서드에서 선언부만 작성하고 구현부를 완성하지 않은 것이 추상메서드이다.

설계만 해놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.

추상메서드도 앞에 abstract를 붙여주며, 구현부가 없으므로 '{}' 대신 문장의 끝을 알리는 ';'을 적는다.

abstract 리턴타입 메서드이름();

추상 클래스로부터 상속받는 자손클래스는 오버라이딩을 해서 추상메서드를 모두 구현해야 한다.

- 추상메서드를 사용하는 이유이다. 
일반 클래스에서 구현을 하지 않고 '{}'만 써도 되지만, abstract를 붙여서 추상메서드로 선언해서 자손클래스에서 반드시 구현하게 강제하기 위함이다.

만약 상속받은 추상메서드 중 하나라도 구현하지 않는다면 자손클래스도 추상클래스로 지정한다.

### writing abstract class

추상의 사전적 정의

> *추상 - 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아
           이를 일반적인 개념으로 파악하는 정신 작용*

**추상화** 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업

**구체화** 상속을 통해 클래스를 구현, 확장하는 작업

**상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라면,**

**추상화는 기존의 클래스의 공통부분을 뽑아내서 조상클래스를 만드는 것이다.**

추상화를 구체화와 반대의 의미로 이해하면 된다.

상속계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해지며,

상속계층도를 따라 올라갈수록 클래스는 추상화의 정도가  심해진다.

즉, 상속계층도를 내려갈수록 세분화되며, 올라갈수록 공통요소만 남는다.

추상클래스 역시 다형성을 활용하여 부모타입의 참조변수 배열을 통해 서로 다른 종류의 자식 인스턴스를 다룰 수 있다.
