

### 오버라이딩 VS 오버로딩

  오버라이딩 : 부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것  
  
  오버로딩    :  기존에 없는 새로운 메서드를 정의하는 것 (매개변수의 개수, 순서 등을 바꿔서)  
  
--- 
### 오버라이딩 조건

  - 이름이 같아야 한다.  
  - 매개변수가 같아야 한다.  
  - 반환타입이 같아야 한다.  
  - 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.  
      - 접근 제어자 범위 내림차순(public, protected, default, private)  
    
  - 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.  
      - 예외의 상속관계도 높으면 안된다.  
      
  - 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.  


  부모 클래스에 정의된 static 메서드를 자식 클래스에서도 똑같은 이름의 static 메서드로 정의할 수 있다.  
  
  호출할 때는 “참조변수.메서드이름()” 보다는 “클래스이름.메서드이름()”으로 하는 게 좋다.
  
---
### super

  클래스의 멤버변수와 지역변수의 이름이 같을 때 this를 사용했듯이,  
  
  부모 클래스의 멤버와 자식의 멤버가 같을 때는 super를 붙여서 구별한다.  
  
  (부모와 자식의 멤버는 중복될 수 있다.)  

```
  class Parent {
    int x = 10;
  }
  class Child extends Parent {
    int x = 20;
  }
  // super.x = 10 / this.x = 20
  다음과 같이
  오버라이딩한 메서드도 super 키워드를 써서 부모 클래스의 메서드를 호출 할 수 있다.
  class Point {
    String getLocation() {
        return "x : "+ x;
    }
  }
  class point3D {
    String getLocation() {
        //return "x : " + x + ", y : " + y;
        super.getLocation() + ", y : " + y;
    }
  }
```

  이렇게 super를 이용해서 부모클래스의 메서드를 포함시킨다면 부모 클래스의 메서드가 변경되었을 때   
  
  변경된 내용이 자손 클래스의 메서드에 자동적으로 반영될 수 있으므로 관리가 편하다.

---
### super()
  super() 는 부모클래스의 생성자이다  
  
  클래스를 상속받으면 자식클래스의 생성자 첫 줄에서  부모 클래스의 생성자를 호출한다.    
  (Object() 생성자까지 계속 호출한다.)  


  그래서 생성자 첫 줄에 super(매개변수)나 this()를 호출해줘야한다. 
  
  호출하지 않으면 컴파일러가 자동으로 super()를 호출한다.   
  
  자식에서 super()를 호출하지 않고 부모 클래스에서 빈 생성자가 없다면 컴파일에러가 발생한다. 
  
  컴파일러는 생성자가 정의되어 있는 클래스에는 기본 생성자를 자동으로 추가하지 않기 때문에 발생하는 오류이다.  
  
  오류를 해결하려면 부모의 생성자에 맞게 super(매개변수)를 호출하면 된다.  
